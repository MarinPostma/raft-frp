use crate::raft_node::RaftNode;
use crate::raft_server::RaftServer;
use tokio::sync::mpsc;
use anyhow::{anyhow, Result};
use crate::raft_service::raft_service_client::RaftServiceClient;
use crate::raft_service::{Empty, ResultCode};
use tonic::Request;
use serde::{Serialize, Deserialize, de::DeserializeOwned};
use bincode::deserialize;
use raft::eraftpb::ConfChange;
use protobuf::Message as _;
use crate::raft_service::ConfigChange;
use std::sync::{RwLock, Arc};


use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct Leader {
    id: u64,
    addr: String,
}

pub trait Store: Send + Sync {
    type Message: Serialize + DeserializeOwned;
    type Error;

    fn apply(&mut self, message: Self::Message) -> Result<(), Self::Error>;
}

#[derive(Debug, Serialize, Deserialize)]
pub enum MyMessage {
    Insert { key: u64, value: String },
}

impl Store for HashMap<u64, String> {
    type Message = MyMessage;
    type Error = String;

    fn apply(&mut self, _message: Self::Message) -> Result<(), Self::Error> {
        unimplemented!()
    }
}

async fn run<S: Store + 'static>(raft_addr: &str, store: Arc<RwLock<S>>) -> Result<()> {
    // TODO: arbitrary buffer length, may need to tune this?
    let (tx, rx) = mpsc::channel(100);
    let node = RaftNode::new(rx, 1);
    let server = RaftServer::new(tx, raft_addr);
    let server_handle = tokio::spawn(server.run());
    let node_handle = tokio::spawn(node.run(store));
    tokio::try_join!(server_handle, node_handle)?;

    Ok(())
}

async fn join<S: Store + 'static>(raft_addr: &str, peer_addr: &str, store: Arc<RwLock<S>>) -> Result<()> {
    // 1. try to discover the leader and obtain an id from it.
    let mut leader_addr = peer_addr.to_string();
    let (mut client, id): (_, u64) = loop {
        let mut client = RaftServiceClient::connect(format!("http://{}", leader_addr)).await?;
        let response = client
            .request_id(Request::new(Empty::default()))
            .await?
            .into_inner();
        match response.code() {
            ResultCode::WrongLeader => {
                let leader: Leader = deserialize(&response.data)?;
                leader_addr = leader.addr;
                continue
            }
            ResultCode::Ok => break (client, deserialize(&response.data)?),
            ResultCode::Error => return Err(anyhow!("join error: {}", deserialize::<String>(&response.data)?)),
        }
    };

    // 2. run server and node to prepare for joining
    let (tx, rx) = mpsc::channel(100);
    let node = RaftNode::new(rx, id);
    let server = RaftServer::new(tx, raft_addr);
    let server_handle = tokio::spawn(server.run());
    let node_handle = tokio::spawn(node.run(store));

    // 3. Join the cluster
    // TODO: handle leader change
    let mut change = ConfChange::default();
    change.set_id(id);
    change.set_node_id(id);
    change.set_context(raft_addr.as_bytes().to_vec());
    client.change_config(Request::new(ConfigChange { inner: change.write_to_bytes()? })).await?;
    tokio::try_join!(server_handle, node_handle)?;

    Ok(())
}
